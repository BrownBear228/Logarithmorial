# Логарифмориал

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
![C++11](https://img.shields.io/badge/C%2B%2B-11-blue.svg)
![Platform](https://img.shields.io/badge/platform-linux%20%7C%20windows%20%7C%20macos-lightgrey)

**Logarithmorial** – это реализация на C++ новой специальной функции  

${Log}(n) = \prod_{k=1}^{n} \ln(k+1) \quad\text{(для натуральных }n\text{)}$

и её аналитического продолжения на все вещественные (и в перспективе комплексные) числа.  
Программа вычисляет значение функции, а также её первую и вторую производные с высокой точностью.

---

## Что такое Логарифмориал?

Логарифмориал (logarithmorial) – это коммониал (обобщение понятия суммы/произведения) с операцией умножения и функцией-операндом $\(\ln(k+1)\)$:

${Log}(n) = \prod_{k=1}^{n} \ln(k+1),\quad n\in\mathbb{N}.$

Для нецелых аргументов функция строится с помощью аналитического продолжения, основанного на представлении

${Log}(x) = \exp( \sum_{k=1}^{\infty} \bigl( \ln\ln(k+1) - \ln\ln(k+x+1) \bigr) + \sum_{k=1}^{\infty} \binom{x}{k} \Delta^{k-1} \ln\ln(N+1))$,

которое эффективно суммируется методом конечных разностей (ряд Ньютона).  
Полученная функция удовлетворяет функциональному уравнению

${Log}(x+1) = {Log}(x)\ln(x+2)$

и является гладкой на $\(0,\infty)$.

Аналитическое продолжение логарифмориала на поле комплексных чисел в данной реализации будет называться Лямбда-функцией Ионина $Λ(z)$.

### Ключевые свойства

- $\{Log}(0) = 1\$ (пустое произведение).
- $\{Log}(1) = \ln 2 \approx 0.693147\$.
- $\{Log}(2) = \ln 2 \cdot \ln 3 \approx 0.7615\$.
- $\{Log}(3) = \ln 2 \cdot \ln 3 \cdot \ln 4 \approx 1.05566\$.
- Функция имеет единственный минимум при  
  $x_{\min} \approx 1.1887199999982840381562709808349609375\$,  
  где $\{Log}(x_{\min}) \approx 0.68847985839830827536900414997944608331\$.
- Первая производная в нуле: $\{Log}'(0) \approx -0.79468781007347122358197566427406854928\$.
- Вторая производная в нуле: $\{Log}''(0) \approx 1.2981338226580874106730334460735321045\$.

---

## История

### Продукториал

Я увлёкся функциями вида ${f_!}(x) = \prod_{k=1}^{n} {f_c}(k)$ и назвал эту конструкцию продукториалом (от product - умножение).

Я стал классифицировать продукториалы по функции-операнду ${f_c}(k)$ и находить аналитическое продолжение для каждого типа.

Например:

- $\prod_{k=1}^{n} a \implies a^n \implies a^z$
- $\prod_{k=1}^{n} a^k \implies \sqrt{a^{n(n+1)}} \implies \sqrt{a^{z(z+1)}}$
- $\prod_{k=1}^{n} ak + b \implies a^n (b/a)!^{-1} (n +  b/a)! \implies a^z \Gamma(b/a + 1)^{-1} \Gamma(z + b/a + 1)$
- $\prod_{k=1}^{n} \ln(k+1) \implies ?$ - давайте разбираться.

### Обобщение на произвольную операцию - Коммониал

${f}(n) = \oplus_{k=1}^{n} {f_c}(k)$

По классификации коммониалов, логарифмориал является продукториалом с логарифмической функцией операндом. Я подумал, что продолжение для суммориала - коммониала с операцией сложения ($\sum$) найти легче, чем для продукториала, и довольно легко нашел связь:

$S_{ln{f_c}}(n) = \ln {f_!}(n) \implies {f_!}(n) = \exp (S_{ln{f_c}}(n))$

Но как теперь найти аналитическое продолжение суммориала?

### Аналитическое продолжение суммориала

$S(x) = \exp( \sum_{k=1}^{\infty} \bigl( {f_c}(k) - {f_c}(k+x) \bigr) + \sum_{k=1}^{\infty} \binom{x}{k} \Delta^{k-1} {f_c}(N+1) )$

Вот она - формула нахождения аналитического продолжения суммориала. Я пытался её вывести сам, искать информацию в открытых источниках в интернете. Но помощь пришла откуда не ждали: я нашел эту формулу в видео на youtube, просто просматривая разные математические видео в качестве хобби.

Ссылка на видео, которое подарило аналитическое продолжение суммориала: [https://youtu.be/hkn9zeRuzHs?si=Y8bsUdmcabMCFVYP].

В нем приводится полное доказательство правдивости этой формулы, очень рекомендую посмотреть.

### Формула для логарифмориала

Вот так и была выведена формула, реализованная в программе:

${Log}(x) = \exp( \sum_{k=1}^{\infty} \bigl( \ln\ln(k+1) - \ln\ln(k+x+1) \bigr) + \sum_{k=1}^{\infty} \binom{x}{k} \Delta^{k-1} \ln\ln(N+1))$

### Производная

Но постойте, в класс Logarithmorial добавлена реализации производной. А как найти производную для продукториала? Ответ кроется также в суммориале. Давайте посмотрим, что будет, если взять производную от суммориала.

$\frac{\partial{\sum_{k=1}^{n} {f_c}(k}}{\partial{x}} =\sum_{k=1}^{n} \frac{\partial{f_c(k)}{\partial{x}}$

---

## Implementation details

Код состоит из одного класса `Logarithmorial`, который использует следующие приёмы:

- **Ряд Ньютона** (конечные разности) для ускорения сходимости бесконечной суммы и аналитического продолжения.
- **Регуляризующие константы** `derivativeConstant` и `secondDerivativeConstant`, полученные из условий в нуле.
- **Биномиальные коэффициенты** для нецелых аргументов, вычисляемые через гамма-функцию (стандартная `std::lgamma`).
- **Три вспомогательные функции-операнда** для значения функции, логарифмической производной и логарифмической второй производной:
  $f_0(x) = \ln\ln(x+1)$,
  $f_1(x) = \frac{1}{(x+1)\ln(x+1)}$,
  $f_2(x) = \frac{\ln(x+1)+1}{(x+1)^2\ln^2(x+1)}.$

Параметры конструктора:
- `depth` – число используемых конечных разностей (по умолчанию 20);
- `arg` – начальная точка, с которой начинается суммирование (по умолчанию 1 000 000, что даёт высокую точность).

Все вычисления ведутся в `double`, поэтому реальная точность составляет около 15–16 десятичных знаков.  
Тем не менее, константы в коде заданы с 38 знаками, что в будущем позволит легко перейти на арифметику произвольной точности.

---

## Getting Started

### Prerequisites

- Компилятор с поддержкой C++11 или новее.
- Стандартная библиотека C++ (заголовки `<iostream>`, `<cmath>`, `<iomanip>` и т.д.).

### Compilation

Скомпилируйте программу любой стандартной командой, например:

```bash
g++ -std=c++11 -O2 logarithmorial.cpp -o logarithmorial

```bash
g++ -std=c++11 -O2 logarithmorial.cpp -o logarithmorial
