# Логарифмориал

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
![C++11](https://img.shields.io/badge/C%2B%2B-11-blue.svg)
![Platform](https://img.shields.io/badge/platform-linux%20%7C%20windows%20%7C%20macos-lightgrey)

**Logarithmorial** – это реализация на C++ новой специальной функции  

${Log}(n) = \prod_{k=1}^{n} \ln(k+1) \quad\text{(для натуральных }n\text{)}$

и её аналитического продолжения на все вещественные (и в перспективе комплексные) числа.  
Программа вычисляет значение функции, а также её первую и вторую производные с высокой точностью.

---

## Что такое Логарифмориал?

Логарифмориал (logarithmorial) – это коммониал (обобщение понятия суммы/произведения) с операцией умножения и функцией-операндом $\(\ln(k+1)\)$:

${Log}(n) = \prod_{k=1}^{n} \ln(k+1),\quad n\in\mathbb{N}.$

Для нецелых аргументов функция строится с помощью аналитического продолжения, основанного на представлении

${Log}(x) = \exp( \sum_{k=1}^{\infty} \bigl( \ln\ln(k+1) - \ln\ln(k+x) \bigr) + \sum_{k=1}^{\infty} \binom{x}{k} * \big\delta^{k-1} ) ,$

которое эффективно суммируется методом конечных разностей (ряд Ньютона).  
Полученная функция удовлетворяет функциональному уравнению

${Log}(x+1) = {Log}(x)\ln(x+2)$

и является гладкой на $\(0,\infty)$.

Аналитическое продолжение логарифмориала на поле комплексных чисел в данной реализации будет называться Лямбда-функцией Ионина $Λ(z)$.

### Ключевые свойства

- $\{Log}(0) = 1\$ (пустое произведение).
- $\{Log}(1) = \ln 2 \approx 0.693147\$.
- $\{Log}(2) = \ln 2 \cdot \ln 3 \approx 0.7615\$.
- $\{Log}(3) = \ln 2 \cdot \ln 3 \cdot \ln 4 \approx 1.05566\$.
- Функция имеет единственный минимум при  
  $x_{\min} \approx 1.1887199999982840381562709808349609375\$,  
  где $\{Log}(x_{\min}) \approx 0.68847985839830827536900414997944608331\$.
- Первая производная в нуле: $\{Log}'(0) \approx -0.79468781007347122358197566427406854928\$.
- Вторая производная в нуле: $\{Log}''(0) \approx 1.2981338226580874106730334460735321045\$.

---

## Implementation details

Код состоит из одного класса `Logarithmorial`, который использует следующие приёмы:

- **Ряд Ньютона** (конечные разности) для ускорения сходимости бесконечной суммы и аналитического продолжения.
- **Регуляризующие константы** `derivativeConstant` и `secondDerivativeConstant`, полученные из условий в нуле.
- **Биномиальные коэффициенты** для нецелых аргументов, вычисляемые через гамма-функцию (стандартная `std::lgamma`).
- **Три вспомогательные функции-операнда** для значения функции, логарифмической производной и логарифмической второй производной:
  $f_0(x) = \ln\ln(x+1)$,
  $f_1(x) = \frac{1}{(x+1)\ln(x+1)}$,
  $f_2(x) = \frac{\ln(x+1)+1}{(x+1)^2\ln^2(x+1)}.$

Параметры конструктора:
- `depth` – число используемых конечных разностей (по умолчанию 20);
- `arg` – начальная точка, с которой начинается суммирование (по умолчанию 1 000 000, что даёт высокую точность).

Все вычисления ведутся в `double`, поэтому реальная точность составляет около 15–16 десятичных знаков.  
Тем не менее, константы в коде заданы с 38 знаками, что в будущем позволит легко перейти на арифметику произвольной точности.

---

## Getting Started

### Prerequisites

- Компилятор с поддержкой C++11 или новее.
- Стандартная библиотека C++ (заголовки `<iostream>`, `<cmath>`, `<iomanip>` и т.д.).

### Compilation

Скомпилируйте программу любой стандартной командой, например:

```bash
g++ -std=c++11 -O2 logarithmorial.cpp -o logarithmorial

```bash
g++ -std=c++11 -O2 logarithmorial.cpp -o logarithmorial
